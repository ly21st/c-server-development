<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>libfuse: include/fuse_common.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libfuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fuse_common.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fuse__opt_8h.html">fuse_opt.h</a>&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__file__info.html">fuse_file_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__buf.html">fuse_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__bufvec.html">fuse_bufvec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2779d57c512b7b948992858653e95f0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a2779d57c512b7b948992858653e95f0e">FUSE_MAJOR_VERSION</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a2779d57c512b7b948992858653e95f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8571aa4ec96e1685d31eeff07cb2f163"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a8571aa4ec96e1685d31eeff07cb2f163">FUSE_MINOR_VERSION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a8571aa4ec96e1685d31eeff07cb2f163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1bacbb44d6dca9a82255c8069c3d69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a4e1bacbb44d6dca9a82255c8069c3d69">FUSE_CAP_ASYNC_READ</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:a4e1bacbb44d6dca9a82255c8069c3d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f6b481e6a7c519fea9250daef6177a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a76f6b481e6a7c519fea9250daef6177a">FUSE_CAP_POSIX_LOCKS</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:a76f6b481e6a7c519fea9250daef6177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c81f2838716f43fe493a61c87a62816"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a4c81f2838716f43fe493a61c87a62816">FUSE_CAP_ATOMIC_O_TRUNC</a>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr class="separator:a4c81f2838716f43fe493a61c87a62816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7686c11aaf80382189927b10b848d8c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a7686c11aaf80382189927b10b848d8c8">FUSE_CAP_EXPORT_SUPPORT</a>&#160;&#160;&#160;(1 &lt;&lt; 4)</td></tr>
<tr class="separator:a7686c11aaf80382189927b10b848d8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd4cebf7ec784886836aa061a1612fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a0cd4cebf7ec784886836aa061a1612fe">FUSE_CAP_DONT_MASK</a>&#160;&#160;&#160;(1 &lt;&lt; 6)</td></tr>
<tr class="separator:a0cd4cebf7ec784886836aa061a1612fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8815e0f48c60c3d9cd6e72be5a84e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a4f8815e0f48c60c3d9cd6e72be5a84e4">FUSE_CAP_SPLICE_WRITE</a>&#160;&#160;&#160;(1 &lt;&lt; 7)</td></tr>
<tr class="separator:a4f8815e0f48c60c3d9cd6e72be5a84e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5da823dc5f202bbe033c7a5a3de9c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#aef5da823dc5f202bbe033c7a5a3de9c4">FUSE_CAP_SPLICE_MOVE</a>&#160;&#160;&#160;(1 &lt;&lt; 8)</td></tr>
<tr class="separator:aef5da823dc5f202bbe033c7a5a3de9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8a51bc70841ab691660413836a9a14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a2f8a51bc70841ab691660413836a9a14">FUSE_CAP_SPLICE_READ</a>&#160;&#160;&#160;(1 &lt;&lt; 9)</td></tr>
<tr class="separator:a2f8a51bc70841ab691660413836a9a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06393448dbb60668f5a3bf0006f536"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#afd06393448dbb60668f5a3bf0006f536">FUSE_CAP_FLOCK_LOCKS</a>&#160;&#160;&#160;(1 &lt;&lt; 10)</td></tr>
<tr class="separator:afd06393448dbb60668f5a3bf0006f536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfb2ecd448cb5659679df690e75581a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a0bfb2ecd448cb5659679df690e75581a">FUSE_CAP_IOCTL_DIR</a>&#160;&#160;&#160;(1 &lt;&lt; 11)</td></tr>
<tr class="separator:a0bfb2ecd448cb5659679df690e75581a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2568c799f5f90ad2f0c353d48d8b8780"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a2568c799f5f90ad2f0c353d48d8b8780">FUSE_CAP_AUTO_INVAL_DATA</a>&#160;&#160;&#160;(1 &lt;&lt; 12)</td></tr>
<tr class="separator:a2568c799f5f90ad2f0c353d48d8b8780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad808b93c66a58d1b4cd738af7ddcf37f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#ad808b93c66a58d1b4cd738af7ddcf37f">FUSE_CAP_READDIRPLUS</a>&#160;&#160;&#160;(1 &lt;&lt; 13)</td></tr>
<tr class="separator:ad808b93c66a58d1b4cd738af7ddcf37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b90333ad08d0e1c2ed0134d9305ee87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a9b90333ad08d0e1c2ed0134d9305ee87">FUSE_CAP_READDIRPLUS_AUTO</a>&#160;&#160;&#160;(1 &lt;&lt; 14)</td></tr>
<tr class="separator:a9b90333ad08d0e1c2ed0134d9305ee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac172aaeb6d27e2fdcafd086f9f3c0cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#aac172aaeb6d27e2fdcafd086f9f3c0cf">FUSE_CAP_ASYNC_DIO</a>&#160;&#160;&#160;(1 &lt;&lt; 15)</td></tr>
<tr class="separator:aac172aaeb6d27e2fdcafd086f9f3c0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4839fce31097f4b4da7a1f01169228fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a4839fce31097f4b4da7a1f01169228fa">FUSE_CAP_WRITEBACK_CACHE</a>&#160;&#160;&#160;(1 &lt;&lt; 16)</td></tr>
<tr class="separator:a4839fce31097f4b4da7a1f01169228fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4477fe76f57e8b726d0357a637d7aaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#ad4477fe76f57e8b726d0357a637d7aaf">FUSE_CAP_NO_OPEN_SUPPORT</a>&#160;&#160;&#160;(1 &lt;&lt; 17)</td></tr>
<tr class="separator:ad4477fe76f57e8b726d0357a637d7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3311a7f569e9fbf55b3f0bcaadbe4ad0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a3311a7f569e9fbf55b3f0bcaadbe4ad0">FUSE_CAP_PARALLEL_DIROPS</a>&#160;&#160;&#160;(1 &lt;&lt; 18)</td></tr>
<tr class="separator:a3311a7f569e9fbf55b3f0bcaadbe4ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3ef5b12be33295311d6b751846c263"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a5b3ef5b12be33295311d6b751846c263">FUSE_CAP_POSIX_ACL</a>&#160;&#160;&#160;(1 &lt;&lt; 19)</td></tr>
<tr class="separator:a5b3ef5b12be33295311d6b751846c263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a4a980dff3f7a4ba771a92bb59a4bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a24a4a980dff3f7a4ba771a92bb59a4bd">FUSE_CAP_HANDLE_KILLPRIV</a>&#160;&#160;&#160;(1 &lt;&lt; 20)</td></tr>
<tr class="separator:a24a4a980dff3f7a4ba771a92bb59a4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade38f8e8c463cd40af5bfeeebfa99486"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#ade38f8e8c463cd40af5bfeeebfa99486">FUSE_IOCTL_COMPAT</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:ade38f8e8c463cd40af5bfeeebfa99486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5e36b839c4dbf0439bd85b61c7213a58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58">fuse_buf_flags</a> { <a class="el" href="fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58affd5b3b7e9cdd5f89b3126eea96e033b">FUSE_BUF_IS_FD</a> = (1 &lt;&lt; 1), 
<a class="el" href="fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58ad67d5c6075febad0594f06d46d02bfa9">FUSE_BUF_FD_SEEK</a> = (1 &lt;&lt; 2), 
<a class="el" href="fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58af89b4b00a2d4a06d8458b320c2cb28cf">FUSE_BUF_FD_RETRY</a> = (1 &lt;&lt; 3)
 }</td></tr>
<tr class="separator:a5e36b839c4dbf0439bd85b61c7213a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0ad71a3e8c357ebe7e87cdecbdbe18"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a> { <a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18adcef8052c48f314d4d9f9f05a5b4f838">FUSE_BUF_NO_SPLICE</a> = (1 &lt;&lt; 1), 
<a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18a375767de945f5178e8949d284abf1f5b">FUSE_BUF_FORCE_SPLICE</a> = (1 &lt;&lt; 2), 
<a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18af239e556066a5d73b3ff542216b157b9">FUSE_BUF_SPLICE_MOVE</a> = (1 &lt;&lt; 3), 
<a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18a32ec833f1eb4b5cd9283cf9d93021037">FUSE_BUF_SPLICE_NONBLOCK</a> = (1 &lt;&lt; 4)
 }</td></tr>
<tr class="separator:aec0ad71a3e8c357ebe7e87cdecbdbe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af5431cea3c9a8490cefe087cb8089cd9"><td class="memItemLeft" align="right" valign="top">struct fuse_conn_info_opts *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#af5431cea3c9a8490cefe087cb8089cd9">fuse_parse_conn_info_opts</a> (struct <a class="el" href="structfuse__args.html">fuse_args</a> *args)</td></tr>
<tr class="separator:af5431cea3c9a8490cefe087cb8089cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cf81fd313a39a171275360960b0471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a55cf81fd313a39a171275360960b0471">fuse_apply_conn_info_opts</a> (struct fuse_conn_info_opts *opts, struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td></tr>
<tr class="separator:a55cf81fd313a39a171275360960b0471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1857d2209952f49a762aff39f3cd8bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#af1857d2209952f49a762aff39f3cd8bd">fuse_daemonize</a> (int foreground)</td></tr>
<tr class="separator:af1857d2209952f49a762aff39f3cd8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04b2f721003f5540c71be65396c53c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#ae04b2f721003f5540c71be65396c53c8">fuse_version</a> (void)</td></tr>
<tr class="separator:ae04b2f721003f5540c71be65396c53c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52e27388a7c16eb509173908e5eebd0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#ac52e27388a7c16eb509173908e5eebd0">fuse_pkgversion</a> (void)</td></tr>
<tr class="separator:ac52e27388a7c16eb509173908e5eebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5027f8a38b2efc03858efd7fdc756a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#adf5027f8a38b2efc03858efd7fdc756a">fuse_pollhandle_destroy</a> (struct fuse_pollhandle *ph)</td></tr>
<tr class="separator:adf5027f8a38b2efc03858efd7fdc756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4327f41b2fe1ca84151b407169bd86c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a4327f41b2fe1ca84151b407169bd86c0">fuse_buf_size</a> (const struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv)</td></tr>
<tr class="separator:a4327f41b2fe1ca84151b407169bd86c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca301390fb5e85b85153abb1891a3f7"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a9ca301390fb5e85b85153abb1891a3f7">fuse_buf_copy</a> (struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *dst, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *src, enum <a class="el" href="fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a> flags)</td></tr>
<tr class="separator:a9ca301390fb5e85b85153abb1891a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292dccc3c7b1799cb054efa2ba0c774b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#a292dccc3c7b1799cb054efa2ba0c774b">fuse_set_signal_handlers</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a292dccc3c7b1799cb054efa2ba0c774b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb674bbc11074c4fe520b952d6bfdd30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse__common_8h.html#aeb674bbc11074c4fe520b952d6bfdd30">fuse_remove_signal_handlers</a> (struct fuse_session *se)</td></tr>
<tr class="separator:aeb674bbc11074c4fe520b952d6bfdd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="aac172aaeb6d27e2fdcafd086f9f3c0cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUSE_CAP_ASYNC_DIO&#160;&#160;&#160;(1 &lt;&lt; 15)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the filesystem supports asynchronous direct I/O submission.</p>
<p>If this capability is not requested/available, the kernel will ensure that there is at most one pending read and one pending write request per direct I/O file-handle at any time.</p>
<p>This feature is enabled by default when supported by the kernel. </p>

</div>
</div>
<a class="anchor" id="a4e1bacbb44d6dca9a82255c8069c3d69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUSE_CAP_ASYNC_READ&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the filesystem supports asynchronous read requests.</p>
<p>If this capability is not requested/available, the kernel will ensure that there is at most one pending read request per file-handle at any time, and will attempt to order read requests by increasing offset.</p>
<p>This feature is enabled by default when supported by the kernel. </p>

</div>
</div>
<a class="anchor" id="a4c81f2838716f43fe493a61c87a62816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUSE_CAP_ATOMIC_O_TRUNC&#160;&#160;&#160;(1 &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the filesystem supports the O_TRUNC open flag</p>
<p>This feature is enabled by default when supported by the kernel. </p>

</div>
</div>
<a class="anchor" id="a2568c799f5f90ad2f0c353d48d8b8780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUSE_CAP_AUTO_INVAL_DATA&#160;&#160;&#160;(1 &lt;&lt; 12)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traditionally, while a file is open the FUSE kernel module only asks the filesystem for an update of the file's attributes when a client attempts to read beyond EOF. This is unsuitable for e.g. network filesystems, where the file contents may change without the kernel knowing about it.</p>
<p>If this flag is set, FUSE will check the validity of the attributes on every read. If the attributes are no longer valid (i.e., if the <em>attr_timeout</em> passed to <a class="el" href="fuse__lowlevel_8h.html#ad28378dc569019c32acdb4995d70be18">fuse_reply_attr()</a> or set in <code>struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a></code> has passed), it will first issue a <code>getattr</code> request. If the new mtime differs from the previous value, any cached file <em>contents</em> will be invalidated as well.</p>
<p>This flag should always be set when available. If all file changes go through the kernel, <em>attr_timeout</em> should be set to zero to avoid unneccessary getattr() calls.</p>
<p>This feature is enabled by default when supported by the ker079656a074">fuse_readdir_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Readdir flags, passed to -&gt;readdir() </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af2bcf2a473b41b3cc8da8c079656a074ad62ab7c23f966a76282921e9187ca441"></a>FUSE_READDIR_PLUS&#160;</td><td class="fielddoc">
<p>"Plus" mode.</p>
<p>The kernel wants to prefill the inode cache during readdir. The filesystem may honour this by filling in the attributes and setting FUSE_FILL_DIR_FLAGS for the filler function. The filesystem may also just ignore this flag completely. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a90f104e6d4e01480161a3300bddbecbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_clean_cache </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>fuse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over cache removing stale entries use in conjunction with "-oremember"</p>
<p>NOTE: This is already done for the standard sessions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuse</td><td>struct fuse pointer for fuse instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of seconds until the next cleanup </dd></dl>

</div>
</div>
<a class="anchor" id="a0d47cac8a295efd5370d7af059e4d14f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_destroy </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the FUSE handle.</p>
<p>NOTE: This function does not unmount the filesystem. If this is needed, call <a class="el" href="fuse_8h.html#aade4d93e323c341fe2859d759e9cb8d8">fuse_unmount()</a> before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the FUSE handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9024935b211288c1869dc7566895d739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_exit </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag session as terminated</p>
<p>This function will cause any running event loops to exit on the next opportunity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the FUSE handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4b0e6955b2fd720542c6c3262fb8761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fuse_fs* fuse_fs_new </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structfuse__operations.html">fuse_operations</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new fuse filesystem object</p>
<p>This is usually called from the factory of a fuse module to create a new instance of a filesystem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>the filesystem operations </td></tr>
    <tr><td class="paramname">op_size</td><td>the size of the <a class="el" href="structfuse__operations.html">fuse_operations</a> structure </td></tr>
    <tr><td class="paramname">user_data</td><td>user data supplied in the context during the init() method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new filesystem object </dd></dl>

</div>
</div>
<a class="anchor" id="a9a0f2a6603cb1e21f5e4c1aec84a3bcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structfuse__context.html">fuse_context</a>* fuse_get_context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current context</p>
<p>The context is only valid for the duration of a filesystem operation, and thus must not be stored and used later.</p>
<dl class="section return"><dt>Returns</dt><dd>the context </dd></dl>

</div>
</div>
<a class="anchor" id="a03baa193b5bfcbe625afbc62e9b97e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fuse_session* fuse_get_session </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get session from fuse object </p>

</div>
</div>
<a class="anchor" id="a04273db088e57d8242caa388193b6958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_getgroups </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>list</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current supplementary group IDs for the current request</p>
<p>Similar to the getgroups(2) system call, except the return value is always the total number of group IDs, even if it is larger than the specified size.</p>
<p>The current fuse kernel module in linux (as of 2.6.30) doesn't pass the group list to userspace, hence this function needs to parse "/proc/$TID/task/$TID/status" to get the group IDs.</p>
<p>This feature may not be supported on all operating systems. In such a case this function will return -ENOSYS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of given array </td></tr>
    <tr><td class="paramname">list</td><td>array of group IDs to be filled in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of supplementary group IDs or -errno on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a0514ca828e6a02a330dcf037292c8803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_interrupted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the current request has already been interrupted</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the request has been interrupted, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6ea805c47ccc960497dfd64e12081159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_loop </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FUSE event loop.</p>
<p>Requests from the kernel are processed, and the appropriate operations are called.</p>
<p>For a description of the return value and the conditions when the event loop exits, refer to the documentation of <a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the FUSE handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see <a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop()</a></dd></dl>
<p>See also: <a class="el" href="fuse_8h.html#a49aa1cd0d8f9e62efd2047de244e318a">fuse_loop_mt()</a> </p>

</div>
</div>
<a class="anchor" id="a49aa1cd0d8f9e62efd2047de244e318a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_loop_mt </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clone_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FUSE event loop with multiple threads</p>
<p>Requests from the kernel are processed, and the appropriate operations are called. Request are processed in parallel by distributing them between multiple threads.</p>
<p>For a description of the return value and the conditions when the event loop exits, refer to the documentation of <a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop()</a>.</p>
<p>Note: using <a class="el" href="fuse_8h.html#a6ea805c47ccc960497dfd64e12081159">fuse_loop()</a> instead of <a class="el" href="fuse_8h.html#a49aa1cd0d8f9e62efd2047de244e318a">fuse_loop_mt()</a> means you are running in single-threaded mode, and that you will not have to worry about reentrancy, though you will have to worry about recursive lookups. In single-threaded mode, FUSE will wait for one callback to return before calling another.</p>
<p>Enabling multiple threads, by using <a class="el" href="fuse_8h.html#a49aa1cd0d8f9e62efd2047de244e318a">fuse_loop_mt()</a>, will cause FUSE to make multiple simultaneous calls into the various callback functions given by your <a class="el" href="structfuse__operations.html">fuse_operations</a> record.</p>
<p>If you are using multiple threads, you can enjoy all the parallel execution and interactive response benefits of threads, and you get to enjoy all the benefits of race conditions and locking bugs, too. Ensure that any code used in the callback function of <a class="el" href="structfuse__operations.html">fuse_operations</a> is also thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the FUSE handle </td></tr>
    <tr><td class="paramname">clone_fd</td><td>whether to use separate device fds for each thread (may increase performance) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see <a class="el" href="fuse__lowlevel_8h.html#a5f1e538aa3287e251afbe985438c4249">fuse_session_loop()</a></dd></dl>
<p>See also: <a class="el" href="fuse_8h.html#a6ea805c47ccc960497dfd64e12081159">fuse_loop()</a> </p>

</div>
</div>
<a class="anchor" id="a2098b9d60626bf749801d12f2d0d6fd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_main_real </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__operations.html">fuse_operations</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The real main function</p>
<p>Do not call this directly, use <a class="el" href="fuse_8h.html#a61755930843c427b79622eda0ad8f083">fuse_main()</a> </p>

</div>
</div>
<a class="anchor" id="a04baffd979b06663ae9590e34a48b55f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_mount </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mountpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mount a FUSE file system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mountpoint</td><td>the mount point path </td></tr>
    <tr><td class="paramname">f</td><td>the FUSE handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4588c85c19c29613e1e7e13748726874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fuse* fuse_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfuse__args.html">fuse_args</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structfuse__operations.html">fuse_operations</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new FUSE filesystem.</p>
<p>This function accepts most file-system independent mount options (like context, nodev, ro - see mount(8)), as well as the FUSE-specific mount options from mount.fuse(8).</p>
<p>If the &ndash;help option is specified, the function writes a help text to stdout and returns NULL.</p>
<p>Option parsing skips argv[0], which is assumed to contain the program name. This element must always be present and is used to construct a basic <code>usage:</code> message for the &ndash;help output. If argv[0] is set to the empty string, no usage message is included in the &ndash;help output.</p>
<p>If an unknown option is passed in, an error message is written to stderr and the function returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>argument vector </td></tr>
    <tr><td class="paramname">op</td><td>the filesystem operations </td></tr>
    <tr><td class="paramname">op_size</td><td>the size of the <a class="el" href="structfuse__operations.html">fuse_operations</a> structure </td></tr>
    <tr><td class="paramname">user_data</td><td>user data supplied in the context during the init() method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created FUSE handle </dd></dl>

</div>
</div>
<a class="anchor" id="a4b2246caec521ec4ac84093f8c4b616d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_start_cleanup_thread </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>fuse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the cleanup thread when using option "remember".</p>
<p>This is done automatically by <a class="el" href="fuse_8h.html#a49aa1cd0d8f9e62efd2047de244e318a">fuse_loop_mt()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuse</td><td>struct fuse pointer for fuse instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and -1 on error </dd></dl>

</div>
</div>
<a class="anchor" id="ad37fd69ba40d5c261f16e207e4a5b0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_stop_cleanup_thread </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>fuse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the cleanup thread when using option "remember".</p>
<p>This is done automatically by <a class="el" href="fuse_8h.html#a49aa1cd0d8f9e62efd2047de244e318a">fuse_loop_mt()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuse</td><td>struct fuse pointer for fuse instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aade4d93e323c341fe2859d759e9cb8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_unmount </td>
          <td>(</td>
          <td class="paramtype">struct fuse *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmount a FUSE file system.</p>
<p>See <a class="el" href="fuse__lowlevel_8h.html#a6c10d942751ddb214863a8b5e53de5e8">fuse_session_unmount()</a> for additional information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the FUSE handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2016 09:31:36 for libfuse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
